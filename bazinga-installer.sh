#!/bin/bash
# BAZINGA Integrator Installer
# This script installs and configures the BAZINGA Integrator

echo "====================================================="
echo "BAZINGA System Integrator Installer"
echo "====================================================="

# Determine home and destination directories
USER_HOME="$HOME"
BAZINGA_HOME="${USER_HOME}/AmsyPycharm/BAZINGA"
BAZINGA_ORG="${USER_HOME}/BAZINGA-Organized"
TOOLS_DIR="${BAZINGA_ORG}/tools"
LOGS_DIR="${BAZINGA_ORG}/logs"

# Create necessary directories
echo "Creating directory structure..."
mkdir -p "${TOOLS_DIR}"
mkdir -p "${LOGS_DIR}"
mkdir -p "${BAZINGA_ORG}/data"
mkdir -p "${BAZINGA_ORG}/reports"
mkdir -p "${BAZINGA_ORG}/artifacts"
mkdir -p "${BAZINGA_ORG}/temp"

# Initialize log file
LOG_FILE="${LOGS_DIR}/install_$(date +%Y%m%d_%H%M%S).log"
echo "Installation started at $(date)" > "${LOG_FILE}"

# Function to log messages
log_message() {
    echo "$1"
    echo "$(date +%Y-%m-%d\ %H:%M:%S): $1" >> "${LOG_FILE}"
}

# Check if BAZINGA home directory exists
if [ ! -d "${BAZINGA_HOME}" ]; then
    log_message "WARNING: BAZINGA home directory not found at ${BAZINGA_HOME}"
    log_message "The integrator will still be installed, but may not detect all components correctly."
    log_message "Please correct the path if necessary in ${BAZINGA_ORG}/integrator_config.json after installation."
fi

# Check Python availability
PYTHON_CMD=""
if command -v python3 &> /dev/null; then
    PYTHON_CMD="python3"
elif command -v python &> /dev/null; then
    PYTHON_CMD="python"
else
    log_message "ERROR: Python not found. Please install Python 3.x and try again."
    exit 1
fi

log_message "Using Python: $(${PYTHON_CMD} --version 2>&1)"

# Check virtualenv
if [ -d "${BAZINGA_HOME}/venv_bazinga" ]; then
    log_message "Found existing BAZINGA virtualenv at ${BAZINGA_HOME}/venv_bazinga"
    PYTHON_CMD="${BAZINGA_HOME}/venv_bazinga/bin/python"
elif [ -f "${USER_HOME}/venv/bin/python" ]; then
    log_message "Found existing virtualenv at ${USER_HOME}/venv"
    PYTHON_CMD="${USER_HOME}/venv/bin/python"
else
    log_message "No existing virtualenv found, will use system Python"
fi

# Install the integrator script
INTEGRATOR_SCRIPT="${TOOLS_DIR}/bazinga_integrator.py"
log_message "Installing integrator script to ${INTEGRATOR_SCRIPT}..."

cat > "${INTEGRATOR_SCRIPT}" << 'EOF'
#!/usr/bin/env python3
"""
BAZINGA System Integrator - Unified Component for SSRI, WhatsApp, and Pattern Recognition

This script provides a unified integration point for the various BAZINGA components,
addressing the common errors observed in the system and providing a central management
interface for the BAZINGA ecosystem.

Author: Generated by Claude for abhissrivasta
Date: March 16, 2025
"""

import os
import sys
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Union, Any
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.expanduser("~/BAZINGA-Organized/logs/integrator.log")),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("BAZINGA-Integrator")

class BazingaIntegrator:
    """Main integrator class for BAZINGA ecosystem components"""
    
    def __init__(self, base_dir: Optional[str] = None):
        """Initialize the BAZINGA integrator with system paths and configuration"""
        self.base_dir = base_dir or os.path.expanduser("~/AmsyPycharm/BAZINGA")
        self.config_dir = os.path.expanduser("~/BAZINGA-Organized")
        self.output_dir = os.path.join(self.config_dir, "artifacts")
        self.ensure_directories()
        
        # Load project configuration
        self.config = self.load_config()
        
        # Component paths
        self.ssri_path = self.config.get("paths", {}).get("ssri_framework", 
                                                        os.path.join(self.base_dir, "src/core/ssri"))
        self.whatsapp_path = self.config.get("paths", {}).get("whatsapp_analysis", 
                                                           os.path.join(self.base_dir, "src/core/whatsapp"))
        self.pattern_path = self.config.get("paths", {}).get("pattern_recognition", 
                                                          os.path.join(self.base_dir, "src/core/pattern"))
        self.visualization_path = self.config.get("paths", {}).get("visualization", 
                                                               os.path.join(self.base_dir, "src/core/visualization"))
        
        logger.info(f"BAZINGA Integrator initialized with base directory: {self.base_dir}")
    
    def ensure_directories(self) -> None:
        """Ensure that required directories exist"""
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(os.path.join(self.config_dir, "logs"), exist_ok=True)
        os.makedirs(os.path.join(self.config_dir, "data"), exist_ok=True)
        os.makedirs(os.path.join(self.config_dir, "reports"), exist_ok=True)
    
    def load_config(self) -> Dict[str, Any]:
        """Load or create configuration for the integrator"""
        config_file = os.path.join(self.config_dir, "integrator_config.json")
        
        if os.path.exists(config_file):
            try:
                with open(config_file, 'r') as f:
                    return json.load(f)
            except json.JSONDecodeError:
                logger.error(f"Error parsing configuration file: {config_file}")
                return self.create_default_config(config_file)
        else:
            return self.create_default_config(config_file)
    
    def create_default_config(self, config_file: str) -> Dict[str, Any]:
        """Create a default configuration file"""
        default_config = {
            "version": "1.0.0",
            "paths": {
                "ssri_framework": os.path.join(self.base_dir, "src/core/ssri"),
                "whatsapp_analysis": os.path.join(self.base_dir, "src/core/whatsapp"),
                "pattern_recognition": os.path.join(self.base_dir, "src/core/pattern"),
                "visualization": os.path.join(self.base_dir, "src/core/visualization")
            },
            "settings": {
                "debug_mode": False,
                "auto_fix_errors": True,
                "generate_reports": True,
                "backup_before_changes": True
            },
            "dependencies": {
                "python_version": "3.13",
                "node_version": "20.x",
                "required_packages": [
                    "numpy", "pandas", "matplotlib", "scikit-learn",
                    "tensorflow", "networkx", "plotly", "dash"
                ]
            }
        }
        
        try:
            with open(config_file, 'w') as f:
                json.dump(default_config, f, indent=2)
            logger.info(f"Created default configuration at {config_file}")
        except Exception as e:
            logger.error(f"Error creating default configuration: {str(e)}")
        
        return default_config
    
    def run_system_diagnostics(self) -> Dict[str, Any]:
        """Run system diagnostics to identify common issues"""
        diagnostic_results = {
            "timestamp": datetime.now().isoformat(),
            "system": {},
            "components": {},
            "errors": [],
            "recommendations": []
        }
        
        # System diagnostics
        try:
            diagnostic_results["system"]["python_version"] = sys.version
            diagnostic_results["system"]["home_dir"] = os.path.expanduser("~")
            diagnostic_results["system"]["disk_space"] = self._get_disk_space()
            diagnostic_results["system"]["environment_vars"] = self._check_environment_variables()
        except Exception as e:
            diagnostic_results["errors"].append(f"System diagnostics error: {str(e)}")
        
        # Component checks
        components = ["ssri_framework", "whatsapp_analysis", "pattern_recognition", "visualization"]
        for component in components:
            try:
                component_path = getattr(self, f"{component.split('_')[0]}_path")
                if os.path.exists(component_path):
                    diagnostic_results["components"][component] = {
                        "exists": True,
                        "path": component_path,
                        "file_count": self._count_files(component_path)
                    }
                else:
                    diagnostic_results["components"][component] = {
                        "exists": False,
                        "path": component_path
                    }
                    diagnostic_results["errors"].append(f"Component not found: {component} at {component_path}")
            except Exception as e:
                diagnostic_results["errors"].append(f"Error checking component {component}: {str(e)}")
        
        # Generate recommendations
        if diagnostic_results["errors"]:
            for error in diagnostic_results["errors"]:
                if "not found" in error:
                    diagnostic_results["recommendations"].append(
                        f"Create missing directory: {error.split('at ')[1]}"
                    )
        
        # Analyze script errors
        script_errors = self._analyze_script_errors()
        diagnostic_results["script_errors"] = script_errors
        
        # Save diagnostic results
        output_file = os.path.join(self.config_dir, "reports", f"diagnostics_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
        try:
            with open(output_file, 'w') as f:
                json.dump(diagnostic_results, f, indent=2)
            logger.info(f"Diagnostic results saved to {output_file}")
        except Exception as e:
            logger.error(f"Error saving diagnostic results: {str(e)}")
        
        return diagnostic_results
    
    def _get_disk_space(self) -> Dict[str, str]:
        """Get disk space information"""
        try:
            if sys.platform == "darwin":  # macOS
                process = subprocess.run(["df", "-h", "/"], capture_output=True, text=True)
                lines = process.stdout.strip().split('\n')
                if len(lines) >= 2:
                    parts = lines[1].split()
                    return {
                        "filesystem": parts[0],
                        "size": parts[1],
                        "used": parts[2],
                        "available": parts[3],
                        "capacity": parts[4]
                    }
            return {"error": "Platform not supported for disk space check"}
        except Exception as e:
            return {"error": str(e)}
    
    def _check_environment_variables(self) -> Dict[str, str]:
        """Check important environment variables"""
        env_vars = ["PATH", "PYTHONPATH", "BAZINGA_HOME", "NODE_PATH"]
        result = {}
        for var in env_vars:
            result[var] = os.environ.get(var, "Not set")
        return result
    
    def _count_files(self, directory: str) -> Dict[str, int]:
        """Count files in a directory by extension"""
        if not os.path.exists(directory):
            return {"error": f"Directory does not exist: {directory}"}
        
        extensions = {}
        try:
            for root, _, files in os.walk(directory):
                for file in files:
                    ext = os.path.splitext(file)[1].lower()
                    if ext in extensions:
                        extensions[ext] += 1
                    else:
                        extensions[ext] = 1
            return extensions
        except Exception as e:
            return {"error": str(e)}
    
    def _analyze_script_errors(self) -> List[Dict[str, str]]:
        """Analyze common script errors and suggest fixes"""
        errors = []
        
        # Check for bash scripts with compatibility issues
        bash_scripts = self._find_files_by_extension(".sh")
        for script in bash_scripts:
            try:
                with open(script, 'r') as f:
                    content = f.read()
                    
                    # Check for associative array declarations
                    if "declare -A" in content:
                        errors.append({
                            "file": script,
                            "error": "Associative array declaration not supported in older bash versions",
                            "fix": "Replace 'declare -A' with compatible alternative or update bash version"
                        })
                    
                    # Check for sed pattern issues
                    if ":a;s/\\B[0-9]\\{3\\}\\>/,&/;ta" in content:
                        errors.append({
                            "file": script,
                            "error": "Sed pattern with label not supported in macOS sed",
                            "fix": "Use alternate pattern or GNU sed: 's/\\B[0-9]\\{3\\}\\>/,&/g'"
                        })
                    
                    # Check for printf issues with floating point
                    if "printf" in content and "$(echo" in content and "bc)" in content:
                        errors.append({
                            "file": script,
                            "error": "Potential issue with printf formatting of floating point numbers",
                            "fix": "Use printf format specifiers like '%.2f' or convert to integer first"
                        })
            except Exception as e:
                errors.append({
                    "file": script,
                    "error": f"Error analyzing script: {str(e)}",
                    "fix": "Manual review required"
                })
        
        return errors
    
    def _find_files_by_extension(self, extension: str) -> List[str]:
        """Find all files with a particular extension"""
        result = []
        for root, _, files in os.walk(self.base_dir):
            for file in files:
                if file.endswith(extension):
                    result.append(os.path.join(root, file))
        return result

    def fix_common_issues(self) -> Dict[str, Any]:
        """Attempt to fix common issues in the BAZINGA system"""
        fixes = {
            "timestamp": datetime.now().isoformat(),
            "applied_fixes": [],
            "errors": []
        }
        
        # Get diagnostic data first
        diagnostics = self.run_system_diagnostics()
        
        # Fix script errors
        if "script_errors" in diagnostics:
            for error in diagnostics["script_errors"]:
                file_path = error.get("file", "")
                if not os.path.exists(file_path):
                    fixes["errors"].append(f"File not found: {file_path}")
                    continue
                    
                try:
                    # Create backup
                    backup_path = f"{file_path}.bak.{datetime.now().strftime('%Y%m%d%H%M%S')}"
                    with open(file_path, 'r') as src, open(backup_path, 'w') as dst:
                        dst.write(src.read())
                    
                    # Apply fix based on error type
                    with open(file_path, 'r') as f:
                        content = f.read()
                    
                    if "Associative array declaration" in error.get("error", ""):
                        # Fix associative array issue
                        content = content.replace("declare -A", "# declare -A - Replaced by BAZINGA Integrator")
                        content = content.replace("-A", "# -A not supported in this bash version")
                        fixes["applied_fixes"].append(f"Fixed associative array in {file_path}")
                    
                    if "Sed pattern with label" in error.get("error", ""):
                        # Fix sed pattern issue
                        content = content.replace(
                            ":a;s/\\B[0-9]\\{3\\}\\>/,&/;ta", 
                            "s/\\B[0-9]\\{3\\}\\>/,&/g # Modified by BAZINGA Integrator"
                        )
                        fixes["applied_fixes"].append(f"Fixed sed pattern in {file_path}")
                    
                    if "printf formatting of floating point" in error.get("error", ""):
                        # This is a more complex fix that would require parsing the script
                        # Just add a comment for now
                        if "printf" in content:
                            content = content.replace(
                                "printf", 
                                "# WARNING: Check floating point formatting\nprintf"
                            )
                            fixes["applied_fixes"].append(f"Added warning for printf in {file_path}")
                    
                    # Write fixed content
                    with open(file_path, 'w') as f:
                        f.write(content)
                
                except Exception as e:
                    fixes["errors"].append(f"Error fixing {file_path}: {str(e)}")
        
        # Create helper scripts
        self._create_helper_scripts()
        fixes["applied_fixes"].append("Created helper scripts in BAZINGA-Organized/tools")
        
        # Report results
        output_file = os.path.join(self.config_dir, "reports", f"fixes_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
        try:
            with open(output_file, 'w') as f:
                json.dump(fixes, f, indent=2)
            logger.info(f"Fix results saved to {output_file}")
        except Exception as e:
            logger.error(f"Error saving fix results: {str(e)}")
        
        return fixes
    
    def _create_helper_scripts(self) -> None:
        """Create helper scripts for common BAZINGA tasks"""
        tools_dir = os.path.join(self.config_dir, "tools")
        os.makedirs(tools_dir, exist_ok=True)
        
        # Create bazinga-wrapper.sh that works around common issues
        wrapper_script = os.path.join(tools_dir, "bazinga-wrapper.sh")
        with open(wrapper_script, 'w') as f:
            f.write("""#!/bin/bash
# BAZINGA Wrapper Script - Created by BAZINGA Integrator
# This script provides compatibility fixes for common issues

# Script arguments
COMMAND="$1"
INPUT="$2"
shift 2
OPTIONS="$@"

# Temporary directory for processing
TEMP_DIR="${HOME}/BAZINGA-Organized/temp"
mkdir -p "${TEMP_DIR}"

# Log file
LOG_FILE="${HOME}/BAZINGA-Organized/logs/bazinga-wrapper.log"
echo "$(date): Running with command: $COMMAND, input: $INPUT, options: $OPTIONS" >> "${LOG_FILE}"

# Function to safely format numbers with commas
format_number() {
    # Compatible version of the sed command
    echo "$1" | sed 's/\\B[0-9]\\{3\\}\\>/,&/g'
}

# Run the appropriate command
case "$COMMAND" in
    generate)
        echo "Generating content for: $INPUT"
        # Run the original script but capture and filter output
        "${HOME}/bazinga.sh" generate "$INPUT" $OPTIONS 2>&1 | tee "${TEMP_DIR}/output.txt"
        ;;
    analyze)
        echo "Analyzing: $INPUT"
        "${HOME}/bazinga.sh" analyze "$INPUT" $OPTIONS 2>&1 | tee "${TEMP_DIR}/output.txt"
        ;;
    visualize)
        echo "Visualizing: $INPUT"
        "${HOME}/bazinga.sh" visualize "$INPUT" $OPTIONS 2>&1 | tee "${TEMP_DIR}/output.txt"
        ;;
    status)
        echo "Checking status"
        "${HOME}/bazinga.sh" status $OPTIONS 2>&1 | tee "${TEMP_DIR}/output.txt"
        ;;
    *)
        echo "Unknown command: $COMMAND"
        echo "Usage: ./bazinga-wrapper.sh <command> <input> [options]"
        echo "Commands: generate, analyze, visualize, status"
        exit 1
        ;;
esac

# Check for common errors in the output and provide workarounds
if grep -q "declare: -A: invalid option" "${TEMP_DIR}/output.txt"; then
    echo "WARNING: Your bash version doesn't support associative arrays."
    echo "Try using a newer version of bash or use the compatibility mode."
fi

if grep -q "unused label" "${TEMP_DIR}/output.txt"; then
    echo "WARNING: Sed pattern issue detected. macOS sed has different syntax."
    echo "Consider installing gnu-sed with: brew install gnu-sed"
fi

echo "Operation completed. Check ${TEMP_DIR}/output.txt for detailed output."
exit 0
""")
        os.chmod(wrapper_script, 0o755)
        
        # Create integration helper script
        integration_script = os.path.join(tools_dir, "bazinga-integration.sh")
        with open(integration_script, 'w') as f:
            f.write("""#!/bin/bash
# BAZINGA Integration Script - Created by BAZINGA Integrator
# This script helps integrate BAZINGA components

BAZINGA_HOME="${HOME}/AmsyPycharm/BAZINGA"
BAZINGA_ORG="${HOME}/BAZINGA-Organized"

# Ensure directories exist
mkdir -p "${BAZINGA_ORG}/logs"
mkdir -p "${BAZINGA_ORG}/temp"
mkdir -p "${BAZINGA_ORG}/reports"

# Function to run the Python integrator
run_python_integrator() {
    if [[ -f "${BAZINGA_ORG}/venv/bin/python" ]]; then
        "${BAZINGA_ORG}/venv/bin/python" "${BAZINGA_ORG}/tools/bazinga_integrator.py" "$@"
    elif [[ -f "${BAZINGA_HOME}/venv_bazinga/bin/python" ]]; then
        "${BAZINGA_HOME}/venv_bazinga/bin/python" "${BAZINGA_ORG}/tools/bazinga_integrator.py" "$@"
    else
        python3 "${BAZINGA_ORG}/tools/bazinga_integrator.py" "$@"
    fi
}

# Command processing
case "$1" in
    diagnose)
        echo "Running system diagnostics..."
        run_python_integrator --diagnose
        ;;
    fix)
        echo "Attempting to fix common issues..."
        run_python_integrator --fix
        ;;
    integrate)
        echo "Integrating BAZINGA components..."
        run_python_integrator --integrate "$2"
        ;;
    visualize)
        echo "Generating visualization..."
        run_python_integrator --visualize "$2"
        ;;
    help|*)
        echo "BAZINGA Integration Helper"
        echo "Usage: ./bazinga-integration.sh <command> [options]"
        echo ""
        echo "Commands:"
        echo "  diagnose     - Run system diagnostics"
        echo "  fix          - Fix common issues"
        echo "  integrate    - Integrate a component (specify component name)"
        echo "  visualize    - Generate visualization (specify data source)"
        echo "  help         - Show this help message"
        ;;
esac
""")
        os.chmod(integration_script, 0o755)
    
    def generate_dependency_graph(self, output_file: Optional[str] = None) -> str:
        """Generate a DOT graph showing component dependencies"""
        if output_file is None:
            output_file = os.path.join(self.config_dir, "reports", f"dependencies_{datetime.now().strftime('%Y%m%d_%H%M%S')}.dot")
        
        dot_content = """digraph BAZINGA {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor=lightblue];
  
  // Core components
  BAZINGA [fillcolor=gold];
  SSRI_Framework [fillcolor=lightgreen];
  WhatsApp_Analysis [fillcolor=lightcoral];
  Pattern_Recognition [fillcolor=lightsalmon];
  Visualization [fillcolor=lightcyan];
  
  // Dependencies
  BAZINGA -> SSRI_Framework;
  BAZINGA -> WhatsApp_Analysis;
  BAZINGA -> Pattern_Recognition;
  SSRI_Framework -> Visualization;
  WhatsApp_Analysis -> Visualization;
  Pattern_Recognition -> Visualization;
  
  // Additional components identified by BAZINGA Integrator
  BAZINGA_Integrator [fillcolor=yellow];
  BAZINGA_Integrator -> BAZINGA;
  BAZINGA_Integrator -> SSRI_Framework;
  BAZINGA_Integrator -> WhatsApp_Analysis;
  BAZINGA_Integrator -> Pattern_Recognition;
  BAZINGA_Integrator -> Visualization;
}
"""
        
        try:
            with open(output_file, 'w') as f:
                f.write(dot_content)
            logger.info(f"Dependency graph saved to {output_file}")
            
            # Try to generate a PNG if graphviz is available
            png_output = os.path.splitext(output_file)[0] + ".png"
            try:
                subprocess.run(["dot", "-Tpng", output_file, "-o", png_output], check=True)
                logger.info(f"Dependency visualization saved to {png_output}")
            except (subprocess.SubprocessError, FileNotFoundError):
                logger.warning("Graphviz not available, PNG visualization not generated")
            
            return output_file
        except Exception as e:
            logger.error(f"Error generating dependency graph: {str(e)}")
            return ""

    def create_dashboard(self) -> None:
        """Create a simple status dashboard for BAZINGA components"""
        dashboard_dir = os.path.join(self.config_dir, "dashboard")
        os.makedirs(dashboard_dir, exist_ok=True)
        
        # Run diagnostics to get fresh data
        diagnostics = self.run_system_diagnostics()
        
        # Create HTML dashboard
        html_file = os.path.join(dashboard_dir, "index.html")
        with open(html_file, 'w') as f:
            f.write(f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAZINGA System Dashboard</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        .header {{ background-color: #4285f4; color: white; padding: 20px; border-radius: 5px; }}
        .card {{ background-color: white; border-radius: 5px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }}
        .component {{ display: flex; margin-bottom: 10px; padding: 10px; border-bottom: 1px solid #eee; }}
        .component-name {{ font-weight: bold; width: 200px; }}
        .component-status {{ flex-grow: 1; }}
        .status-ok {{ color: green; }}
        .status-warning {{ color: orange; }}
        .status-error {{ color: red; }}
        .footer {{ text-align: center; margin-top: 40px; color: #666; font-size: 0.8em; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>BAZINGA System Dashboard</h1>
            <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </div>
        
        <div class="card">
            <h2>System Overview</h2>
            <div class="component">
                <div class="component-name">Python Version:</div>
                <div class="component-status">{diagnostics.get('system', {}).get('python_version', 'Unknown')}</div>
            </div>
            <div class="component">
                <div class="component-name">Disk Space:</div>
                <div class="component-status">
                    {diagnostics.get('system', {}).get('disk_space', {}).get('available', 'Unknown')} available
                    ({diagnostics.get('system', {}).get('disk_space', {}).get('capacity', 'Unknown')} used)
                </div>
            </div>
            <div class="component">
                <div class="component-name">Base Directory:</div>
                <div class="component-status">{self.base_dir}</div>
            </div>
        </div>
        
        <div class="footer">
            <p>Generated by BAZINGA Integrator v1.0.0</p>
            <p>Â© 2025 BAZINGA Project</p>
        </div>
    </div>
</body>
</html>
""")
        
        logger.info(f"Dashboard created at {html_file}")
        print(f"Dashboard created at {html_file}")


def main():
    """Main function to run the BAZINGA integrator"""
    import argparse
    
    parser = argparse.ArgumentParser(description="BAZINGA System Integrator")
    parser.add_argument("--base-dir", help="Base directory for BAZINGA project")
    parser.add_argument("--diagnose", action="store_true", help="Run system diagnostics")
    parser.add_argument("--fix", action="store_true", help="Fix common issues")
    parser.add_argument("--dashboard", action="store_true", help="Create system dashboard")
    parser.add_argument("--graph", action="store_true", help="Generate dependency graph")
    parser.add_argument("--integrate", help="Integrate specific component")
    parser.add_argument("--all", action="store_true", help="Run all operations")
    parser.add_argument("--output-dir", help="Output directory for reports and artifacts")
    
    args = parser.parse_args()
    
    # Initialize integrator
    integrator = BazingaIntegrator(base_dir=args.base_dir)
    
    if args.output_dir:
        integrator.output_dir = args.output_dir
        os.makedirs(args.output_dir, exist_ok=True)
    
    # Run requested operations
    if args.all or args.diagnose:
        print("Running system diagnostics...")
        results = integrator.run_system_diagnostics()
        print(f"Found {len(results.get('errors', []))} errors and {len(results.get('script_errors', []))} script issues")
    
    if args.all or args.fix:
        print("Attempting to fix common issues...")
        fixes = integrator.fix_common_issues()
        print(f"Applied {len(fixes.get('applied_fixes', []))} fixes with {len(fixes.get('errors', []))} errors")
    
    if args.all or args.graph:
        print("Generating dependency graph...")
        graph_file = integrator.generate_dependency_graph()
        print(f"Dependency graph saved to {graph_file}")
    
    if args.all or args.dashboard:
        print("Creating system dashboard...")
        integrator.create_dashboard()
    
    if args.integrate:
        print(f"Integration of '{args.integrate}' component would go here")
        # This would be implemented based on specific integration requirements
    
    print("BAZINGA Integrator operations completed")


if __name__ == "__main__":
    main()
EOF

# Make script executable
chmod +x "${INTEGRATOR_SCRIPT}"
log_message "Integration script installed successfully"

# Create wrapper script
WRAPPER_SCRIPT="${TOOLS_DIR}/bazinga-run.sh"
cat > "${WRAPPER_SCRIPT}" << 'EOF'
#!/bin/bash
# BAZINGA Integration Runner
# This script provides a unified interface to the BAZINGA integrator

BAZINGA_ORG="${HOME}/BAZINGA-Organized"
PYTHON_SCRIPT="${BAZINGA_ORG}/tools/bazinga_integrator.py"

# Check if Python script exists
if [ ! -f "${PYTHON_SCRIPT}" ]; then
    echo "ERROR: Integration script not found at ${PYTHON_SCRIPT}"
    exit 1
fi

# Find best Python to use
if [ -f "${HOME}/AmsyPycharm/BAZINGA/venv_bazinga/bin/python" ]; then
    PYTHON_CMD="${HOME}/AmsyPycharm/BAZINGA/venv_bazinga/bin/python"
elif [ -f "${HOME}/venv/bin/python" ]; then
    PYTHON_CMD="${HOME}/venv/bin/python"
elif command -v python3 &> /dev/null; then
    PYTHON_CMD="python3"
else
    PYTHON_CMD="python"
fi

# Print banner
echo "====================================================="
echo "BAZINGA Integrator"
echo "====================================================="
echo "Using Python: $(${PYTHON_CMD} --version 2>&1)"
echo "Integration script: ${PYTHON_SCRIPT}"
echo "BAZINGA home: ${HOME}/AmsyPycharm/BAZINGA"
echo "Organization home: ${BAZINGA_ORG}"
echo "====================================================="

# Run script with arguments
"${PYTHON_CMD}" "${PYTHON_SCRIPT}" "$@"
exit_code=$?

if [ ${exit_code} -eq 0 ]; then
    echo "====================================================="
    echo "Operation completed successfully"
    echo "See ${BAZINGA_ORG}/logs/integrator.log for details"
    echo "====================================================="
else
    echo "====================================================="
    echo "Operation failed with exit code ${exit_code}"
    echo "Check ${BAZINGA_ORG}/logs/integrator.log for details"
    echo "====================================================="
fi

exit ${exit_code}
EOF

chmod +x "${WRAPPER_SCRIPT}"
log_message "Wrapper script installed successfully"

# Create basic documentation
cat > "${BAZINGA_ORG}/README.md" << EOF
# BAZINGA System Integrator

This directory contains the BAZINGA System Integrator, a tool for managing and integrating
components of the BAZINGA project ecosystem.

## Directory Structure

- \`tools/\`: Scripts and utilities for the integrator
- \`logs/\`: Log files from integrator operations
- \`reports/\`: Generated reports and diagnostics
- \`data/\`: Data files used by the integrator
- \`artifacts/\`: Generated artifacts and outputs
- \`temp/\`: Temporary files

## Usage

To run the integrator, use the wrapper script:

\`\`\`
${WRAPPER_SCRIPT} --all
\`\`\`

For specific operations:

\`\`\`
${WRAPPER_SCRIPT} --diagnose    # Run system diagnostics
${WRAPPER_SCRIPT} --fix         # Fix common issues
${WRAPPER_SCRIPT} --dashboard   # Create system dashboard
${WRAPPER_SCRIPT} --graph       # Generate dependency graph
\`\`\`

## Generated Files

- System diagnostics are saved to \`reports/diagnostics_*.json\`
- Fix reports are saved to \`reports/fixes_*.json\`
- Dependency graphs are saved to \`reports/dependencies_*.dot\` and \`reports/dependencies_*.png\`
- Dashboard is available at \`dashboard/index.html\`

## Configuration

The integrator configuration is stored in \`integrator_config.json\`. You can edit this file
to customize paths, settings, and dependencies.

Created: $(date)
EOF

log_message "Documentation created"

# Run initial setup
log_message "Running initial setup..."
"${PYTHON_CMD}" "${INTEGRATOR_SCRIPT}" --diagnose

log_message "Installation completed successfully!"
echo ""
echo "====================================================="
echo "BAZINGA Integrator installed successfully!"
echo "====================================================="
echo ""
echo "Documentation: ${BAZINGA_ORG}/README.md"
echo "Run the integrator with: ${WRAPPER_SCRIPT} --help"
echo ""
echo "To get started, run:"
echo "  ${WRAPPER_SCRIPT} --all"
echo ""
echo "Thank you for installing the BAZINGA Integrator!"
echo "====================================================="
