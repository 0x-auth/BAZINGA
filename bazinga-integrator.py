#!/usr/bin/env python3
"""
BAZINGA System Integrator - Unified Component for SSRI, WhatsApp, and Pattern Recognition

This script provides a unified integration point for the various BAZINGA components,
addressing the common errors observed in the system and providing a central management
interface for the BAZINGA ecosystem.

Author: Generated by Claude for abhissrivasta
Date: March 16, 2025
"""

import os
import sys
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Union, Any
from datetime import datetime

# Configure logging
logging.basicConfig(
    level = logging.INFO,
    format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers = [
        logging.FileHandler(os.path.expanduser("~/BAZINGA-Organized/logs/integrator.log")),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("BAZINGA-Integrator")

class BazingaIntegrator:
    """Main integrator class for BAZINGA ecosystem components"""

    def __init__(self, base_dir: Optional[str] = None):
        """Initialize the BAZINGA integrator with system paths and configuration"""
        self.base_dir = base_dir or os.path.expanduser("~/AmsyPycharm/BAZINGA")
        self.config_dir = os.path.expanduser("~/BAZINGA-Organized")
        self.output_dir = os.path.join(self.config_dir, "artifacts")
        self.ensure_directories()

        # Load project configuration
        self.config = self.load_config()

        # Component paths
        self.ssri_path = self.config.get("paths", {}).get("ssri_framework",
                                                        os.path.join(self.base_dir, "src/core/ssri"))
        self.whatsapp_path = self.config.get("paths", {}).get("whatsapp_analysis",
                                                           os.path.join(self.base_dir, "src/core/whatsapp"))
        self.pattern_path = self.config.get("paths", {}).get("pattern_recognition",
                                                          os.path.join(self.base_dir, "src/core/pattern"))
        self.visualization_path = self.config.get("paths", {}).get("visualization",
                                                               os.path.join(self.base_dir, "src/core/visualization"))

        logger.info(f"BAZINGA Integrator initialized with base directory: {self.base_dir}")

    def ensure_directories(self) -> None:
        """Ensure that required directories exist"""
        os.makedirs(self.output_dir, exist_ok = True)
        os.makedirs(os.path.join(self.config_dir, "logs"), exist_ok = True)
        os.makedirs(os.path.join(self.config_dir, "data"), exist_ok = True)
        os.makedirs(os.path.join(self.config_dir, "reports"), exist_ok = True)

    def load_config(self) -> Dict[str, Any]:
        """Load or create configuration for the integrator"""
        config_file = os.path.join(self.config_dir, "integrator_config.json")

        if os.path.exists(config_file):
            try:
                with open(config_file, 'r') as f:
                    return json.load(f)
            except json.JSONDecodeError:
                logger.error(f"Error parsing configuration file: {config_file}")
                return self.create_default_config(config_file)
        else:
            return self.create_default_config(config_file)

    def create_default_config(self, config_file: str) -> Dict[str, Any]:
        """Create a default configuration file"""
        default_config = {
            "version": "1.0.0",
            "paths": {
                "ssri_framework": os.path.join(self.base_dir, "src/core/ssri"),
                "whatsapp_analysis": os.path.join(self.base_dir, "src/core/whatsapp"),
                "pattern_recognition": os.path.join(self.base_dir, "src/core/pattern"),
                "visualization": os.path.join(self.base_dir, "src/core/visualization")
            },
            "settings": {
                "debug_mode": False,
                "auto_fix_errors": True,
                "generate_reports": True,
                "backup_before_changes": True
            },
            "dependencies": {
                "python_version": "3.13",
                "node_version": "20.x",
                "required_packages": [
                    "numpy", "pandas", "matplotlib", "scikit-learn",
                    "tensorflow", "networkx", "plotly", "dash"
                ]
            }
        }

        try:
            with open(config_file, 'w') as f:
                json.dump(default_config, f, indent = 2)
            logger.info(f"Created default configuration at {config_file}")
        except Exception as e:
            logger.error(f"Error creating default configuration: {str(e)}")

        return default_config

    def run_system_diagnostics(self) -> Dict[str, Any]:
        """Run system diagnostics to identify common issues"""
        diagnostic_results = {
            "timestamp": datetime.now().isoformat(),
            "system": {},
            "components": {},
            "errors": [],
            "recommendations": []
        }

        # System diagnostics
        try:
            diagnostic_results["system"]["python_version"] = sys.version
            diagnostic_results["system"]["home_dir"] = os.path.expanduser("~")
            diagnostic_results["system"]["disk_space"] = self._get_disk_space()
            diagnostic_results["system"]["environment_vars"] = self._check_environment_variables()
        except Exception as e:
            diagnostic_results["errors"].append(f"System diagnostics error: {str(e)}")

        # Component checks
        components = ["ssri_framework", "whatsapp_analysis", "pattern_recognition", "visualization"]
        for component in components:
            try:
                component_path = getattr(self, f"{component.split('_')[0]}_path")
                if os.path.exists(component_path):
                    diagnostic_results["components"][component] = {
                        "exists": True,
                        "path": component_path,
                        "file_count": self._count_files(component_path)
                    }
                else:
                    diagnostic_results["components"][component] = {
                        "exists": False,
                        "path": component_path
                    }
                    diagnostic_results["errors"].append(f"Component not found: {component} at {component_path}")
            except Exception as e:
                diagnostic_results["errors"].append(f"Error checking component {component}: {str(e)}")

        # Generate recommendations
        if diagnostic_results["errors"]:
            for error in diagnostic_results["errors"]:
                if "not found" in error:
                    diagnostic_results["recommendations"].append(
                        f"Create missing directory: {error.split('at ')[1]}"
                    )

        # Analyze script errors
        script_errors = self._analyze_script_errors()
        diagnostic_results["script_errors"] = script_errors

        # Save diagnostic results
        output_file = os.path.join(self.config_dir, "reports", f"diagnostics_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
        try:
            with open(output_file, 'w') as f:
                json.dump(diagnostic_results, f, indent = 2)
            logger.info(f"Diagnostic results saved to {output_file}")
        except Exception as e:
            logger.error(f"Error saving diagnostic results: {str(e)}")

        return diagnostic_results

    def _get_disk_space(self) -> Dict[str, str]:
        """Get disk space information"""
        try:
            if sys.platform == "darwin":  # macOS
                process = subprocess.run(["df", "-h", "/"], capture_output = True, text = True)
                lines = process.stdout.strip().split('\n')
                if len(lines) >= 2:
                    parts = lines[1].split()
                    return {
                        "filesystem": parts[0],
                        "size": parts[1],
                        "used": parts[2],
                        "available": parts[3],
                        "capacity": parts[4]
                    }
            return {"error": "Platform not supported for disk space check"}
        except Exception as e:
            return {"error": str(e)}

    def _check_environment_variables(self) -> Dict[str, str]:
        """Check important environment variables"""
        env_vars = ["PATH", "PYTHONPATH", "BAZINGA_HOME", "NODE_PATH"]
        result = {}
        for var in env_vars:
            result[var] = os.environ.get(var, "Not set")
        return result

    def _count_files(self, directory: str) -> Dict[str, int]:
        """Count files in a directory by extension"""
        if not os.path.exists(directory):
            return {"error": f"Directory does not exist: {directory}"}

        extensions = {}
        try:
            for root, _, files in os.walk(directory):
                for file in files:
                    ext = os.path.splitext(file)[1].lower()
                    if ext in extensions:
                        extensions[ext] += 1
                    else:
                        extensions[ext] = 1
            return extensions
        except Exception as e:
            return {"error": str(e)}

    def _analyze_script_errors(self) -> List[Dict[str, str]]:
        """Analyze common script errors and suggest fixes"""
        errors = []

        # Check for bash scripts with compatibility issues
        bash_scripts = self._find_files_by_extension(".sh")
        for script in bash_scripts:
            try:
                with open(script, 'r') as f:
                    content = f.read()

                    # Check for associative array declarations
                    if "declare -A" in content:
                        errors.append({
                            "file": script,
                            "error": "Associative array declaration not supported in older bash versions",
                            "fix": "Replace 'declare -A' with compatible alternative or update bash version"
                        })

                    # Check for sed pattern issues
                    if ":a;s/\\B[0-9]\\{3\\}\\>/, &/;ta" in content:
                        errors.append({
                            "file": script,
                            "error": "Sed pattern with label not supported in macOS sed",
                            "fix": "Use alternate pattern or GNU sed: 's/\\B[0-9]\\{3\\}\\>/, &/g'"
                        })

                    # Check for printf issues with floating point
                    if "printf" in content and "$(echo" in content and "bc)" in content:
                        errors.append({
                            "file": script,
                            "error": "Potential issue with printf formatting of floating point numbers",
                            "fix": "Use printf format specifiers like '%.2f' or convert to integer first"
                        })
            except Exception as e:
                errors.append({
                    "file": script,
                    "error": f"Error analyzing script: {str(e)}",
                    "fix": "Manual review required"
                })

        return errors

    def _find_files_by_extension(self, extension: str) -> List[str]:
        """Find all files with a particular extension"""
        result = []
        for root, _, files in os.walk(self.base_dir):
            for file in files:
                if file.endswith(extension):
                    result.append(os.path.join(root, file))
        return result

    def fix_common_issues(self) -> Dict[str, Any]:
        """Attempt to fix common issues in the BAZINGA system"""
        fixes = {
            "timestamp": datetime.now().isoformat(),
            "applied_fixes": [],
            "errors": []
        }

        # Get diagnostic data first
        diagnostics = self.run_system_diagnostics()

        # Fix script errors
        if "script_errors" in diagnostics:
            for error in diagnostics["script_errors"]:
                file_path = error.get("file", "")
                if not os.path.exists(file_path):
                    fixes["errors"].append(f"File not found: {file_path}")
                    continue

                try:
                    # Create backup
                    backup_path = f"{file_path}.bak.{datetime.now().strftime('%Y%m%d%H%M%S')}"
                    with open(file_path, 'r') as src, open(backup_path, 'w') as dst:
                        dst.write(src.read())

                    # Apply fix based on error type
                    with open(file_path, 'r') as f:
                        content = f.read()

                    if "Associative array declaration" in error.get("error", ""):
                        # Fix associative array issue
                        content = content.replace("declare -A", "# declare -A - Replaced by BAZINGA Integrator")
                        content = content.replace("-A", "# -A not supported in this bash version")
                        fixes["applied_fixes"].append(f"Fixed associative array in {file_path}")

                    if "Sed pattern with label" in error.get("error", ""):
                        # Fix sed pattern issue
                        content = content.replace(
                            ":a;s/\\B[0-9]\\{3\\}\\>/, &/;ta",
                            "s/\\B[0-9]\\{3\\}\\>/, &/g # Modified by BAZINGA Integrator"
                        )
                        fixes["applied_fixes"].append(f"Fixed sed pattern in {file_path}")

                    if "printf formatting of floating point" in error.get("error", ""):
                        # This is a more complex fix that would require parsing the script
                        # Just add a comment for now
                        if "printf" in content:
                            content = content.replace(
                                "printf",
                                "# WARNING: Check floating point formatting\nprintf"
                            )
                            fixes["applied_fixes"].append(f"Added warning for printf in {file_path}")

                    # Write fixed content
                    with open(file_path, 'w') as f:
                        f.write(content)

                except Exception as e:
                    fixes["errors"].append(f"Error fixing {file_path}: {str(e)}")

        # Create helper scripts
        self._create_helper_scripts()
        fixes["applied_fixes"].append("Created helper scripts in BAZINGA-Organized/tools")

        # Report results
        output_file = os.path.join(self.config_dir, "reports", f"fixes_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
        try:
            with open(output_file, 'w') as f:
                json.dump(fixes, f, indent = 2)
            logger.info(f"Fix results saved to {output_file}")
        except Exception as e:
            logger.error(f"Error saving fix results: {str(e)}")

        return fixes

    def _create_helper_scripts(self) -> None:
        """Create helper scripts for common BAZINGA tasks"""
        tools_dir = os.path.join(self.config_dir, "tools")
        os.makedirs(tools_dir, exist_ok = True)

        # Create bazinga-wrapper.sh that works around common issues
        wrapper_script = os.path.join(tools_dir, "bazinga-wrapper.sh")
        with open(wrapper_script, 'w') as f:
            f.write("""#!/bin/bash
# BAZINGA Wrapper Script - Created by BAZINGA Integrator
# This script provides compatibility fixes for common issues

# Script arguments
COMMAND = "$1"
INPUT = "$2"
shift 2
OPTIONS = "$@"

# Temporary directory for processing
TEMP_DIR = "${HOME}/BAZINGA-Organized/temp"
mkdir -p "${TEMP_DIR}"

# Log file
LOG_FILE = "${HOME}/BAZINGA-Organized/logs/bazinga-wrapper.log"
echo "$(date): Running with command: $COMMAND, input: $INPUT, options: $OPTIONS" >> "${LOG_FILE}"

# Function to safely format numbers with commas
format_number() {
    # Compatible version of the sed command
    echo "$1" | sed 's/\\B[0-9]\\{3\\}\\>/, &/g'
}

# Run the appropriate command
case "$COMMAND" in
    generate)
        echo "Generating content for: $INPUT"
        # Run the original script but capture and filter output
        "${HOME}/bazinga.sh" generate "$INPUT" $OPTIONS 2>&1 | tee "${TEMP_DIR}/output.txt"
        ;;
    analyze)
        echo "Analyzing: $INPUT"
        "${HOME}/bazinga.sh" analyze "$INPUT" $OPTIONS 2>&1 | tee "${TEMP_DIR}/output.txt"
        ;;
    visualize)
        echo "Visualizing: $INPUT"
        "${HOME}/bazinga.sh" visualize "$INPUT" $OPTIONS 2>&1 | tee "${TEMP_DIR}/output.txt"
        ;;
    status)
        echo "Checking status"
        "${HOME}/bazinga.sh" status $OPTIONS 2>&1 | tee "${TEMP_DIR}/output.txt"
        ;;
    *)
        echo "Unknown command: $COMMAND"
        echo "Usage: ./bazinga-wrapper.sh <command> <input> [options]"
        echo "Commands: generate, analyze, visualize, status"
        exit 1
        ;;
esac

# Check for common errors in the output and provide workarounds
if grep -q "declare: -A: invalid option" "${TEMP_DIR}/output.txt"; then
    echo "WARNING: Your bash version doesn't support associative arrays."
    echo "Try using a newer version of bash or use the compatibility mode."
fi

if grep -q "unused label" "${TEMP_DIR}/output.txt"; then
    echo "WARNING: Sed pattern issue detected. macOS sed has different syntax."
    echo "Consider installing gnu-sed with: brew install gnu-sed"
fi

echo "Operation completed. Check ${TEMP_DIR}/output.txt for detailed output."
exit 0
""")
        os.chmod(wrapper_script, 0o755)

        # Create integration helper script
        integration_script = os.path.join(tools_dir, "bazinga-integration.sh")
        with open(integration_script, 'w') as f:
            f.write("""#!/bin/bash
# BAZINGA Integration Script - Created by BAZINGA Integrator
# This script helps integrate BAZINGA components

BAZINGA_HOME = "${HOME}/AmsyPycharm/BAZINGA"
BAZINGA_ORG = "${HOME}/BAZINGA-Organized"

# Ensure directories exist
mkdir -p "${BAZINGA_ORG}/logs"
mkdir -p "${BAZINGA_ORG}/temp"
mkdir -p "${BAZINGA_ORG}/reports"

# Function to run the Python integrator
run_python_integrator() {
    if [[ -f "${BAZINGA_ORG}/venv/bin/python" ]]; then
        "${BAZINGA_ORG}/venv/bin/python" "${BAZINGA_ORG}/tools/bazinga_integrator.py" "$@"
    elif [[ -f "${BAZINGA_HOME}/venv_bazinga/bin/python" ]]; then
        "${BAZINGA_HOME}/venv_bazinga/bin/python" "${BAZINGA_ORG}/tools/bazinga_integrator.py" "$@"
    else
        python3 "${BAZINGA_ORG}/tools/bazinga_integrator.py" "$@"
    fi
}

# Command processing
case "$1" in
    diagnose)
        echo "Running system diagnostics..."
        run_python_integrator --diagnose
        ;;
    fix)
        echo "Attempting to fix common issues..."
        run_python_integrator --fix
        ;;
    integrate)
        echo "Integrating BAZINGA components..."
        run_python_integrator --integrate "$2"
        ;;
    visualize)
        echo "Generating visualization..."
        run_python_integrator --visualize "$2"
        ;;
    help|*)
        echo "BAZINGA Integration Helper"
        echo "Usage: ./bazinga-integration.sh <command> [options]"
        echo ""
        echo "Commands:"
        echo "  diagnose     - Run system diagnostics"
        echo "  fix          - Fix common issues"
        echo "  integrate    - Integrate a component (specify component name)"
        echo "  visualize    - Generate visualization (specify data source)"
        echo "  help         - Show this help message"
        ;;
esac
""")
        os.chmod(integration_script, 0o755)

        # Copy the Python integrator script
        integrator_script = os.path.join(tools_dir, "bazinga_integrator.py")
        with open(integrator_script, 'w') as f:
            with open(__file__, 'r') as src:
                f.write(src.read())
        os.chmod(integrator_script, 0o755)

    def generate_dependency_graph(self, output_file: Optional[str] = None) -> str:
        """Generate a DOT graph showing component dependencies"""
        if output_file is None:
            output_file = os.path.join(self.config_dir, "reports", f"dependencies_{datetime.now().strftime('%Y%m%d_%H%M%S')}.dot")

        dot_content = """digraph BAZINGA {
  rankdir = LR;
  node [shape = box, style = filled, fillcolor = lightblue];

  // Core components
  BAZINGA [fillcolor = gold];
  SSRI_Framework [fillcolor = lightgreen];
  WhatsApp_Analysis [fillcolor = lightcoral];
  Pattern_Recognition [fillcolor = lightsalmon];
  Visualization [fillcolor = lightcyan];

  // Dependencies
  BAZINGA -> SSRI_Framework;
  BAZINGA -> WhatsApp_Analysis;
  BAZINGA -> Pattern_Recognition;
  SSRI_Framework -> Visualization;
  WhatsApp_Analysis -> Visualization;
  Pattern_Recognition -> Visualization;

  // Additional components identified by BAZINGA Integrator
  BAZINGA_Integrator [fillcolor = yellow];
  BAZINGA_Integrator -> BAZINGA;
  BAZINGA_Integrator -> SSRI_Framework;
  BAZINGA_Integrator -> WhatsApp_Analysis;
  BAZINGA_Integrator -> Pattern_Recognition;
  BAZINGA_Integrator -> Visualization;
}
"""

        try:
            with open(output_file, 'w') as f:
                f.write(dot_content)
            logger.info(f"Dependency graph saved to {output_file}")

            # Try to generate a PNG if graphviz is available
            png_output = os.path.splitext(output_file)[0] + ".png"
            try:
                subprocess.run(["dot", "-Tpng", output_file, "-o", png_output], check = True)
                logger.info(f"Dependency visualization saved to {png_output}")
            except (subprocess.SubprocessError, FileNotFoundError):
                logger.warning("Graphviz not available, PNG visualization not generated")

            return output_file
        except Exception as e:
            logger.error(f"Error generating dependency graph: {str(e)}")
            return ""

    def create_dashboard(self) -> None:
        """Create a simple status dashboard for BAZINGA components"""
        dashboard_dir = os.path.join(self.config_dir, "dashboard")
        os.makedirs(dashboard_dir, exist_ok = True)

        # Run diagnostics to get fresh data
        diagnostics = self.run_system_diagnostics()

        # Create HTML dashboard
        html_file = os.path.join(dashboard_dir, "index.html")
        with open(html_file, 'w') as f:
            f.write(f"""<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width = device-width, initial-scale = 1.0">
    <title>BAZINGA System Dashboard</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        .header {{ background-color: #4285f4; color: white; padding: 20px; border-radius: 5px; }}
        .card {{ background-color: white; border-radius: 5px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }}
        .component {{ display: flex; margin-bottom: 10px; padding: 10px; border-bottom: 1px solid #eee; }}
        .component-name {{ font-weight: bold; width: 200px; }}
        .component-status {{ flex-grow: 1; }}
        .status-ok {{ color: green; }}
        .status-warning {{ color: orange; }}
        .status-error {{ color: red; }}
        .footer {{ text-align: center; margin-top: 40px; color: #666; font-size: 0.8em; }}
    </style>
</head>
<body>
    <div class = "container">
        <div class = "header">
            <h1>BAZINGA System Dashboard</h1>
            <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </div>

        <div class = "card">
            <h2>System Overview</h2>
            <div class = "component">
                <div class = "component-name">Python Version:</div>
                <div class = "component-status">{diagnostics.get('system', {}).get('python_version', 'Unknown')}</div>
            </div>
            <div class = "component">
                <div class = "component-name">Disk Space:</div>
                <div class = "component-status">
                    {diagnostics.get('system', {}).get('disk_space', {}).get('available', 'Unknown')} available
                    ({diagnostics.get('system', {}).get('disk_space', {}).get('capacity', 'Unknown')} used)
                </div>
            </div>
            <div class = "component">
                <div class = "component-name">Base Directory:</div>
                <div class = "component-status">{self.base_dir}</div>
            </div>
        </div>

        <div class = "card">
            <h2>Components Status</h2>
""")

            # Add component statuses
            for component, data in diagnostics.get('components', {}).items():
                status_class = "status-ok" if data.get('exists', False) else "status-error"
                status_text = "OK" if data.get('exists', False) else "Not Found"
                f.write(f"""            <div class = "component">
                <div class = "component-name">{component.replace('_', ' ').title()}:</div>
                <div class = "component-status {status_class}">{status_text}</div>
            </div>
""")

            # Add errors
            f.write("""        </div>

        <div class = "card">
            <h2>Issues Detected</h2>
""")

            if diagnostics.get('errors', []):
                for error in diagnostics.get('errors', []):
                    f.write(f"""            <div class = "component">
                <div class = "component-name">Error:</div>
                <div class = "component-status status-error">{error}</div>
            </div>
""")
            else:
                f.write("""            <div class = "component">
                <div class = "component-name">Status:</div>
                <div class = "component-status status-ok">No critical issues detected</div>
            </div>
""")

            # Add script errors
            if diagnostics.get('script_errors', []):
                f.write("""
            <h3>Script Issues</h3>
""")
                for error in diagnostics.get('script_errors', []):
                    f.write(f"""            <div class = "component">
                <div class = "component-name">{os.path.basename(error.get('file', 'Unknown'))}:</div>
                <div class = "component-status status-warning">{error.get('error', 'Unknown issue')}</div>
            </div>
""")

            # Add recommendations
            f.write("""        </div>

        <div class = "card">
            <h2>Recommendations</h2>
""")

            if diagnostics.get('recommendations', []):
                for rec in diagnostics.get('recommendations', []):
                    f.write(f"""            <div class = "component">
                <div class = "component-name">Action:</div>
                <div class = "component-status">{rec}</div>
            </div>
""")
            else:
                f.write("""            <div class = "component">
                <div class = "component-name">Status:</div>
                <div class = "component-status">No specific recommendations at this time</div>
            </div>
""")

            # Add footer and close tags
            f.write("""        </div>

        <div class = "footer">
            <p>Generated by BAZINGA Integrator v1.0.0</p>
            <p>Â© 2025 BAZINGA Project</p>
        </div>
    </div>
</body>
</html>
""")

        logger.info(f"Dashboard created at {html_file}")
        print(f"Dashboard created at {html_file}")


def main():
    """Main function to run the BAZINGA integrator"""
    import argparse

    parser = argparse.ArgumentParser(description = "BAZINGA System Integrator")
    parser.add_argument("--base-dir", help = "Base directory for BAZINGA project")
    parser.add_argument("--diagnose", action = "store_true", help = "Run system diagnostics")
    parser.add_argument("--fix", action = "store_true", help = "Fix common issues")
    parser.add_argument("--dashboard", action = "store_true", help = "Create system dashboard")
    parser.add_
